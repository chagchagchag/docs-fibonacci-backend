(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[590],{6426:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/kubernetes-overview/kubernetes-resource-assignment",function(){return s(3598)}])},3598:function(e,n,s){"use strict";s.r(n),s.d(n,{__toc:function(){return d}});var r=s(5893),i=s(2673),c=s(373),o=s(8426);s(9128);var a=s(2643);let d=[{depth:2,value:"Kubernetes Pod 의 자원 설정",id:"kubernetes-pod-의-자원-설정"},{depth:2,value:"resources : Pod 의 Resource",id:"resources--pod-의-resource"},{depth:3,value:"1) requests : 최소로 필요한 기본적인 자원의 크기 등을 명시",id:"1-requests--최소로-필요한-기본적인-자원의-크기-등을-명시"},{depth:3,value:"2) limits : 최대한도로 사용할 수 있는 제한(Limit)을 의미",id:"2-limits--최대한도로-사용할-수-있는-제한limit을-의미"},{depth:2,value:"memory, cpu 의 단위 (Mi, Gi, m)",id:"memory-cpu-의-단위-mi-gi-m"},{depth:2,value:"Pod 의 성능, 자원, Replicas 설정 기준",id:"pod-의-성능-자원-replicas-설정-기준"},{depth:2,value:"Replica 조정 (Deployment)",id:"replica-조정-deployment"},{depth:2,value:"스케일링 꿀팁",id:"스케일링-꿀팁"},{depth:2,value:"CPU Resource 설정",id:"cpu-resource-설정"},{depth:2,value:"JVM 메모리 설정",id:"jvm-메모리-설정"},{depth:3,value:"주의할 점 : 레거시 JVM 은 request, limits 를 인식하지 못한다.",id:"주의할-점--레거시-jvm-은-request-limits-를-인식하지-못한다"},{depth:3,value:"가장 오래된 JVM 중 Container 관련 기능이 패치되었을 가능성 있는 버전",id:"가장-오래된-jvm-중-container-관련-기능이-패치되었을-가능성-있는-버전"},{depth:3,value:"UseContainerSupport 옵션",id:"usecontainersupport-옵션"},{depth:3,value:"Container 의 메모리, JVM 의 힙 메모리",id:"container-의-메모리-jvm-의-힙-메모리"},{depth:3,value:"힙 메모리 옵션들",id:"힙-메모리-옵션들"},{depth:4,value:"-Xms, -Xmx",id:"-xms--xmx"},{depth:4,value:"-XX:InitialRamPercentage, -XX:MaxRamPercentage",id:"-xxinitialrampercentage--xxmaxrampercentage"},{depth:4,value:"-XX:+ExitOnOutOfMemoryError",id:"-xxexitonoutofmemoryerror"}];function _createMdxContent(e){let n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre",span:"span",h3:"h3",ul:"ul",li:"li",h4:"h4"},(0,a.a)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"kubernetes-pod-의-자원-설정",children:"Kubernetes Pod 의 자원 설정"}),"\n",(0,r.jsxs)(n.p,{children:["애플리케이션의 구조, 동작, 프레임워크에 따라 달라지기 때문에 모니터링을 통해 측정을 한 후에 자원을 설정하는 경우가 많다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["또는 애플리케이션에 대해서 성능 테스트를 수행해본다던가 실제로 운영을 하면서 자원사용량 들을 모니터링을 하면서 CPU가 부족한지 메모리가 여유있는지, 힙메모리가 부족한지, 가비지 컬렉션 등이 발생하는지 이런 것들을 보면서 판단을 내리는 과정 역시 중요하다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["Pod의 수량에 따라서 CPU, Memory 사용량 역시 달라질 수 있는데 파드가 많아지면 CPU 사용량은 줄고, 메모리 사용량은 늘어나고 파드가 적어지면 CPU 사용량은 늘고 메모리 사용량은 줄어들고 하는 이런 내용들이 달라질 수 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["Pod 하나에 대해서 테스트와 모니터링을 해보면서 Pod가 요구하는 CPU, Memory 최소 요구값, 최대 상한선을 미리 정한다면 이 것을 바탕으로 적정한 자원 할당량을 정할 수 있고 파드 수량을 정할 수도 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["주의할 점이 있다. Pod 의 수량을 늘린다고 해서 무조건 성능을 선형적으로 올려주지는 않는 다는 사실을 이해해야 한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["1기의 Pod로 운영되던 것을 10개로 늘린다고 해서 처리량 까지 10배로 늘어나는 것은 아니다. 병목구간이 얼마나 적은지 애플리케이션이 얼마나 독립적으로 요청을 처리할 수 있는지에 따라 파드의 수량을 결정하는 것이 현명하다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["Stateless 한 애플리케이션 이면서 데이터베이스 처리량이 높다면 보통은 스케일 아웃을 통해서 성능 향상을 하는 것이 효율을 보인다. 그렇지 않을 경우에는 스케일아웃을 통한 성능 향상은 효과를 크게 보지 못한다. 이런 경우 파드의 수량을 두배, 세배까지 올려도 성능향상을 얻지 못하는 경우가 많다. 트래픽이 높다고 해서 애플리케이션의 파드 수량을 100배, 1000배 까지 올린다고해서 성능향상을 확실하게 얻을 수 있는 것은 아니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["애플리케이션의 성격, 구조에 따라서 스케일아웃, 스케일업을 할지에 대한 관점도 달라지게 된다. 예를 들어 Spring MVC 의 경우 스레드를 많이 사용하는데 CPU 자원이 많지 않으면 제대로 성능이 나오기 쉽지 않다. Spring Boot 의 경우 스레드를 200개 까지 만들어내는데 일반적으로 요청들이 DB 작업 등으로 인해 블로킹 되어서 대기하는 그런 시간들이 많기 때문에 일반적으로 스프링 MVC 의 경우에는 스레드를 많이 만들고 많이 유지하는 경우가 많다. 즉, CPU 자원 자체를 1core 미만으로 잡으면 좋은 성능을 내기 쉽지 않다. 이런 경우에는 CPU 자체를 늘리는 것이 파드의 수량을 늘리는 것보다 중요하다고 할 수 있다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["반면, 스레드를 사용하지 않고 이벤트 루프를 이용해서 처리하는 비동기 서버들이 최근 많아지는 추세인데 이런 파드들의 경우에는 파드를 스케일 업 해주기보다는 CPU를 1 core 이하로 할당한 다수의 파드를 운영하는 스케일 아웃 형태가 적절하다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["마지막으로 노드의 자원을 여유를 두고 사용하는 것 역시 중요하다. 노드 자원을 모두 사용하게끔 타이트하게 파드의 스케일 아웃을 스펙으로 잡아두었다면 파드의 업데이트, 스케일 아웃 시에 파드가 자주 Pending 상태에 걸리게 된다. 이렇게 되면 쿠버네티스의 빠른 확장, 빠른 배포라는 장점을 활용하지 못하게 된다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["노드에 여유가 없어서 새로운 노드를 추가하는 과정에서는 노드를 추가하는 데에 시간이 상당 시간 소요되는 편이고(파드 생성에 비해 노드 생성은 큰 작업이므로) 노드가 새로 추가되었을 때 새로운 노드로 파드 들이 몰린다거나 하는 현상이 발생할 수 있어서 이런 부분들이 단점이 될 수 있다. 따라서 트래픽이 급격하게 증가했을 때에도 대응이 가능한 수준을 노드의 사양을 설정하는 것 역시 중요하다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.h2,{id:"resources--pod-의-resource",children:[(0,r.jsx)(n.code,{children:"resources"})," : Pod 의 Resource"]}),"\n",(0,r.jsxs)(n.p,{children:["requests, limits 는 효과적인 스케일링이 가능하도록 하게 하려면 가급적 정의를 꼭 해주는 것이 좋습니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.pre,{"data-language":"yaml","data-theme":"default",filename:"something-resource.yml",hasCopyCode:!0,children:(0,r.jsxs)(n.code,{"data-language":"yaml","data-theme":"default",children:[(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"resources"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"requests"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-comment)"},children:"## 1) "})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"memory"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:'"512Mi"'})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"cpu"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:'"250m"'})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"limits"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-comment)"},children:"## 2)"})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"memory"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:'"1Gi"'})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"cpu"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:'"500m"'})]})]})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"1-requests--최소로-필요한-기본적인-자원의-크기-등을-명시",children:"1) requests : 최소로 필요한 기본적인 자원의 크기 등을 명시"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"requests 는 주로 파드(Pod)가 노드 내에 배포될 때 노드 내에서 파드 하나가 확보해야 하는 자원의 크기를 의미한다."}),"\n",(0,r.jsx)(n.li,{children:'파드가 노드 내에 배포될 때 노드 내에서 "파드 하나에 대해 최소 이 정도는 있어야 한다"를 의미'}),"\n",(0,r.jsx)(n.li,{children:"가급적 애플리케이션이 안정적으로 돌아갈 수 있는 최소한도의 자원의 크기로 설정해줘야 한다."}),"\n",(0,r.jsx)(n.li,{children:"만약 노드가 requests 에 해당하는 자원만큼을 할당할 만한 여력이 없다면 Pod 자체를 스케쥴링하지 않고 Pending 상태로 둔 후 자원이 남는 노드가 생길 때 까지 대기한다."}),"\n",(0,r.jsx)(n.li,{children:"requests 에 명시하는 자원은 어떠한 경우에도 무조건 노드가 이 파드에 대해서 이 정도의 자원을 확보해야 한다는 의미이기에 이 값을 너무 크게 잡으면 유휴 자원으로 인해 리소스 낭비가 심해진다."}),"\n",(0,r.jsx)(n.li,{children:"만약 requests 를 무분별하게 크게 잡은 파드들이 많아서 노드의 자원의 크기를 넘어설 정도가 된다면 노드 자체가 가득 차서 파드 들이 스케쥴링되지 않는 상황이 발생할 수 있다는 점을 유의해야 한다."}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"2-limits--최대한도로-사용할-수-있는-제한limit을-의미",children:"2) limits : 최대한도로 사용할 수 있는 제한(Limit)을 의미"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"limits 는 파드가 노드 내에서 최대한도로 사용할 수 있는 제한(Limit)을 의미한다"}),"\n",(0,r.jsx)(n.li,{children:"파드가 최대 어느 정도의 자원까지 사용이 가능한지를 명시한다."}),"\n",(0,r.jsx)(n.li,{children:"limits 에 할당하는 자원들의 스펙은 꼭 쿠버네티스가 이 정도까지 확보해준다는 의미는 아니다."}),"\n",(0,r.jsxs)(n.li,{children:["만약 노드에 자원이 여유가 없다면, 쿠버네티스는 ",(0,r.jsx)(n.code,{children:"requests"})," 에 해당하는 한계까지만 채운다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"limits"})," 에 설정하는 스펙은 자원이 무한대로 증가해서 노드를 잠식해버리는 상황을 방지할 수 있게끔 한계값을 설정해줄 수 있는 역할을 한다."]}),"\n",(0,r.jsxs)(n.li,{children:["만약 ",(0,r.jsx)(n.code,{children:"limits"})," 를 설정하지 않으면 애플리케이션이 자원을 사용할 수 있는 자원의 상한이 정해지지 않았기 때문에 애플리케이션이 노드의 자원스펙을 모두 사용하게 되는 상황이 발생할 수 있다."]}),"\n",(0,r.jsxs)(n.li,{children:["노드의 자원을 모두 사용할 수 있다는 점이 장점으로 보일 수도 있지만 그 노드의 자원을 낭비하게 되기도 하고 다른 파드의 스케쥴링이 방해되기도 하고 노드의 자원이 얼마나 남아있는지 여부에 걸려있는지에 파드의 스케일링이 결정되는 계획되지 않은 스케쥴링이 될 수 있는 요소가 강하기에 가급적이면 ",(0,r.jsx)(n.code,{children:"limits"})," 를 설정하는 것이 권장되는 편"]}),"\n",(0,r.jsxs)(n.li,{children:["메모리 같은 요소의 경우 특정 프로세스에 자원이 할당이 되면은 사용하고 있는 자원이 별로 없더라도 잘 반납이 안되는 경우가 많기도 하기 때문에 그래서 문제가 심각해질 수도 있기에 가급적 ",(0,r.jsx)(n.code,{children:"limits"})," 를 설정해주는 것이 권장되는 편"]}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"memory-cpu-의-단위-mi-gi-m",children:"memory, cpu 의 단위 (Mi, Gi, m)"}),"\n",(0,r.jsxs)(n.p,{children:["memory 에는 Mi, Gi 를 주로 단위를 사용한다. 일반적으로는 Mi는 비트 단위 MB는 바이트 단위, Gi 는 비트 단위 GB 바이트 단위로 인식되는데, Mi 는 MB보다 조금 더 크게 잡힐 수 있고, Gi 는 GB 는 더 크게 잡힐 수 있다. JVM 메모리 지정시 대부분 MB, GB 단위로 지정하는데, Mi, Gi와 엄청나게 큰 숫자 차이는 나지 않는다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["즉, 세부적으로 따지면 조금은 다른 의미이긴 하지만 MB, GB와 비슷한 단위로 파악하는 것이 완전하게 틀려지는 방식은 아니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["cpu 에는 주로 ",(0,r.jsx)(n.code,{children:"m"})," 이라는 단위를 사용한다. 컨테이너가 할당받는 CPU Time 을 코어로 환산한다. 1 코어당 ",(0,r.jsx)(n.code,{children:"1000m"})," 으로 환산해서 계산한다. ",(0,r.jsx)("br",{}),"\r\n예를 들어 1코어(=1000m) 기반의 노드에서 ",(0,r.jsx)(n.code,{children:"500m"})," 은 1/2 코어를 의미한다. 만약 8코어(=8000m) 기반의 노드에서 ",(0,r.jsx)(n.code,{children:"2000m"})," 은 1/5 x 8 = 5/8 = 1.6 코어 를 의미한다."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"pod-의-성능-자원-replicas-설정-기준",children:"Pod 의 성능, 자원, Replicas 설정 기준"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CPU, Memory 의 크기를 성능테스트 or 모니터링을 통해 결정"}),"\n",(0,r.jsx)(n.li,{children:"Pod 의 수량을 늘린다고 해서 성능을 선형적으로 올려주지는 않는다."}),"\n",(0,r.jsx)(n.li,{children:"비즈니스의 동작 방식에 따라 수직적, 수평적 스케일링의 효과가 달라진다."}),"\n",(0,r.jsx)(n.li,{children:"노드의 자원이 허용되는 한도 내에서 어느 정도의 여유를 두고 스케일링 설정을 하자."}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"replica-조정-deployment",children:"Replica 조정 (Deployment)"}),"\n",(0,r.jsxs)(n.p,{children:["Deployment 에는 ",(0,r.jsx)(n.code,{children:"replicas"})," 를 조정해서 Pod 의 수량을 조절할 수 있다."]}),"\n",(0,r.jsx)(n.pre,{"data-language":"yaml","data-theme":"default",filename:"deployment.yaml",hasCopyCode:!0,children:(0,r.jsxs)(n.code,{"data-language":"yaml","data-theme":"default",children:[(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"kind"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:"Deployment"})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"metadata"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"name"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string-expression)"},children:"my-app"})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"spec"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-comment)"},children:"### spec 내의 replicas 를 수정해서 Pod 의 갯수를 조정할 수 있다."})]}),"\n",(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:"replicas"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-constant)"},children:"5"})]})]})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:["주로 ",(0,r.jsx)(n.code,{children:"spec.replicas"})," 를 조정해서 수량을 조정할 수 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.p,{children:"아래의 명령어를 통해 동적으로 변경하는 것 역시 가능하다. 트래픽이 급작스럽게 증가했을 경우에 아래와 같은 명령어로 스케일링을 늘리기도 한다."}),"\n",(0,r.jsx)(n.pre,{"data-language":"bash","data-theme":"default",filename:"bash",hasCopyCode:!0,children:(0,r.jsx)(n.code,{"data-language":"bash","data-theme":"default",children:(0,r.jsxs)(n.span,{className:"line",children:[(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-function)"},children:"$"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string)"},children:"kubectl"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string)"},children:"scale"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string)"},children:"deployment"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string)"},children:"my-app"}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,r.jsx)(n.span,{style:{color:"var(--shiki-token-string)"},children:"--replicas=5"})]})})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:["이렇게 명령어로 진행한 내용은 실제 스펙에는 반영되지 않으므로 다음 배포 때에 늘려주었던 만큼의 레플리카가 실제로 필요하다면 스펙에 반영해서 배포를 진행하면 된다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["replicas 숫자를 늘릴 경우에는 기존 파드에 영향 없이 새로운 파드가 추가되는 것으로 스케일링이 이뤄진다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"스케일링-꿀팁",children:"스케일링 꿀팁"}),"\n",(0,r.jsxs)(n.p,{children:["초반에는 애플리케이션이 몇개의 파드로 실행되어야 하고 각각의 파드가 노드 내에서 어떤 사양으로 실행될 지를 정의하는 파드의 성능에 대한 수직적 스케일링과 파드의 갯수 등을 고려한 수평적 스케일링을 정의한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["운영 시에는 트래픽이 예상했던 것 보다 더 많이 들어올 수 있기 때문에 이 때부터는 수평적으로 스케일링을 하면서 대응을 해나간다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"cpu-resource-설정",children:"CPU Resource 설정"}),"\n",(0,r.jsxs)(n.p,{children:["CPU 리소스의 경우 1core 또는 1000m(1000 밀리코어) 와 같은 단위로 표시된다.",(0,r.jsx)("br",{}),"\r\nCPU 리소스 지정시에는 주로 ",(0,r.jsx)(n.code,{children:"m"})," 이라는 단위를 사용해서 표기한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["컨테이너가 할당받는 CPU Time 을 코어로 환산한다. 1 코어당 ",(0,r.jsx)(n.code,{children:"1000m"})," 으로 환산해서 계산한다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["노드의 CPU core 를 2로 지정한다고 해서 core 2개를 프로세스에 물리적으로 할당했다는 의미가 아니라는 점에 유의해야 한다. 노드가 가지고 있는 전체 코어 중에서 컨테이너가 요청한 CPU 코어 양에 맞게 CPU Time 을 비율로 따져서 비율에 맞도록 CPU Time 을 할당해준다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["예를 들어 1코어(=1000m) 기반의 노드에서 ",(0,r.jsx)(n.code,{children:"500m"})," 은 1/2 코어만큼의 CPU Time 을 의미한다. 만약 8코어(=8000m) 기반의 노드에서 ",(0,r.jsx)(n.code,{children:"2000m"})," 은 2000/8000 = 1/4 = 0.25 코어만큼의 CPU Time 을 의미한다. 만약 ",(0,r.jsx)(n.code,{children:"1000m"})," 을 지정하면 1 core 정도의 CPU Time을 할당받은 것을 의미한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["노드의 OS 입장에서는 컨테이너가 여러 개 떠있고 이 컨테이너들을 시분할을 통해서 동일하게 시간을 분배해주면서 컨텍스트 스위칭을 하면서 멀티테스킹을 해야 하는 방식이라는 것을 떠올리면 CPU Time 단위로 Core 를 분배하는 것에 대한 개념을 이해가 가능하다. ",(0,r.jsx)(n.code,{children:"1000m"})," 을 CPU 스펙에 정의하면 딱 잘라서 1Core 만 사용하는 싱글스레드 기반이라는 의미가 아니라 1 core 만큼의 CPU Time 을 사용하는 것을 의미한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["CPU Time 의 경우 정밀하게 CPU의 코어 만큼의 시간이 적용된다기보다는 조금 더 사용될 수도 있고 덜 사용될 수 도 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h2,{id:"jvm-메모리-설정",children:"JVM 메모리 설정"}),"\n",(0,r.jsxs)(n.h3,{id:"주의할-점--레거시-jvm-은-request-limits-를-인식하지-못한다",children:["주의할 점 : 레거시 JVM 은 ",(0,r.jsx)(n.code,{children:"request"}),", ",(0,r.jsx)(n.code,{children:"limits"})," 를 인식하지 못한다."]}),"\n",(0,r.jsxs)(n.p,{children:["주의할 점이 있다. Docker Container 환경이 나오기 전의 버전이나, Docker Container 환경이 고려되지 않은 비교적 레거시 버전의 JVM이 있는데 이 레거시 버전의 JVM 들은 파드에 지정한 ",(0,r.jsx)(n.code,{children:"requests"}),", ",(0,r.jsx)(n.code,{children:"limits"})," 를 인식하지 못한다. 이런 이유로 레거시 버전의 JVM 들은 노드의 물리적 메모리를 자신이 사용할 수 있는 메모리의 상한 값으로 생각하고 메모리를 사용하는 문제가 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["즉, JVM 자신이 Docker container 내에서 구동 중이라는 것을 인식하는 기능이 추가되지 않은 레거시 버전의 JDK 버전들은 ",(0,r.jsx)(n.code,{children:"requests"}),", ",(0,r.jsx)(n.code,{children:"limits"})," 대신 JVM 옵션 (",(0,r.jsx)(n.code,{children:"Xmx"}),", ",(0,r.jsx)(n.code,{children:"Xms"})," 등)을 따로 지정해줘야 한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h3,{id:"가장-오래된-jvm-중-container-관련-기능이-패치되었을-가능성-있는-버전",children:"가장 오래된 JVM 중 Container 관련 기능이 패치되었을 가능성 있는 버전"}),"\n",(0,r.jsxs)(n.p,{children:["JVM 8 버전 중에서는 가급적 후반버전에 이 부분에 대한 패치가 되어있을 수 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h3,{id:"usecontainersupport-옵션",children:"UseContainerSupport 옵션"}),"\n",(0,r.jsxs)(n.p,{children:["JVM 이 Container 내에서 구동한다는 것을 명시하기 위해서 ",(0,r.jsx)(n.code,{children:"UseContainerSupport"})," 옵션을 활성화하기도 하는데, 최신버전에 가까운 JVM 일수록 ",(0,r.jsx)(n.code,{children:"UseContainerSupport"})," 옵션은 기본으로 활성화되어 있기에 최신버전에 가까운 JVM을 사용할 경우 굳이 ",(0,r.jsx)(n.code,{children:"UseContainerSupport"})," 옵션을 명시하지 않아도 된다..",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"UseContainerSupport"})," 옵션을 비활성화 하는 것도 가능한데, 굳이 비활성화 하는 것으로 얻을 수 있는 이득이 없기에 비활성화 하는 것은 권장되지 않는다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h3,{id:"container-의-메모리-jvm-의-힙-메모리",children:"Container 의 메모리, JVM 의 힙 메모리"}),"\n",(0,r.jsxs)(n.p,{children:["Container 의 메모리와 JVM 의 힙 메모리는 서로 다른 제한을 갖게 된다.",(0,r.jsx)("br",{}),"\r\nJVM 은 힙 메모리 외에도 여러 종류의 메모리를 사용하는데, 만약 heap 메모리 옵션을 지정하지 않으면, Container 가 확보해둔 메모리의 4분의 1 정도를 heap 메모리로 할당한다. 이렇게 되면 예를 들어 Container 가 1GB 의 메모리를 확보했을 때 Heap 메모리는 256 MB 만 사용할 수 있게 된다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["따라서 이렇게 256MB 만 사용할 수 있는 경우처럼 heap 메모리가 과도하게 작게 설정되는 경우를 방지하려면 별도의 JVM 옵션으로 Heap 메모리 옵션을 지정해줘야 한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h3,{id:"힙-메모리-옵션들",children:"힙 메모리 옵션들"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-Xms"}),", ",(0,r.jsx)(n.code,{children:"-Xmx"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-XX:InitialRamPercentage"}),", ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})]}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.h4,{id:"-xms--xmx",children:[(0,r.jsx)(n.code,{children:"-Xms"}),", ",(0,r.jsx)(n.code,{children:"-Xmx"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-Xms"}),", ",(0,r.jsx)(n.code,{children:"-Xmx"})," 의 경우 다소 오래된 버전의 JVM에서 사용되는 옵션이고 Heap 메모리를 고정적으로 할당하는 방식이다. 하지만, 보통 k8s 애플리케이션은 배포 시 마다 노드의 환경이나 배포 구성방식에 따라서 파드의 메모리가 바뀔 수도 있다. 이런 경우 고정적으로 할당된 ",(0,r.jsx)(n.code,{children:"-Xms"}),", ",(0,r.jsx)(n.code,{children:"-Xmx"})," 로 배포된 파드에 대한 이미지까지 재 빌드 후 배포해야 하게 된다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["이렇게 ",(0,r.jsx)(n.code,{children:"-Xms"}),", ",(0,r.jsx)(n.code,{children:"-Xmx"})," 옵션이 인프라(노드)에 종속적인 면 때문에 ",(0,r.jsx)(n.code,{children:"-XX:InitialRamPercentage"}),", ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})," 이 추가됐다. 메모리 할당 사이즈를 비율로 지정할 수 있는 옵션이다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.h4,{id:"-xxinitialrampercentage--xxmaxrampercentage",children:[(0,r.jsx)(n.code,{children:"-XX:InitialRamPercentage"}),", ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-XX:InitialRamPercentage"}),", ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})," 을 동일하게 설정하는 경우가 있는데 이런 경우 힙 메모리를 고정적으로 할당해서 가비지 컬렉션 관련 이슈를 줄여줄 수 있다는 점에서 좋은 설정이 될 수 있다. (애플리케이션이 초기 구동 후 계속해서 힙 메모리가 필요할 때마다 키워나가기 때문)",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-XX:InitialRamPercentage"}),"를 50% 로 줄지, ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})," 를 70% 로 줄지 이런 비율들은 컨테이너에 어느 정도의 메모리 자원이 비율이 할당이 되었는지 수치와 애플리케이션이 사용하는 힙메모리의 비율, 논 힙 메모리를 어느 정도 사용하는지 등의 크기에 따라서 달라질 수 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["일반적으로 50% 정도의 수치에서부터 테스트를 해보면서 모니터링 도구를 통해 수치를 확인해가면서 힙 메모리를 더줘야 할지 줄여야할 지 이런 비율등에 대해 적정 비율을 찾아가면서 높여가면서 설정하는 것이 좋은 설정이다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["이 비율을 처음부터 너무 높게 적용할 경우 Non Heap 메모리에 할당될 메모리의 비율이 줄어들게 되는데 이런 경우 애플리케이션 자체가 정상적으로 기동되지 않을 수 있기 때문에 이런 경우에 대해서는 조심을 해야 한다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"-xxexitonoutofmemoryerror",children:(0,r.jsx)(n.code,{children:"-XX:+ExitOnOutOfMemoryError"})}),"\n",(0,r.jsxs)(n.p,{children:["애플리케이션이 받는 트래픽이 점점 증가하면서 메모리 사용량이 늘어나다가 결국은 할당된 메모리를 모두 사용하게 되었을 경우를 생각해보자.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["자바의 경우 메모리 사용량이 상한 값에 도달하게 될 경우 가비지컬렉션이 발생해서 CPU 사용량이 늘어나게 되고 가비지컬렉션을 통해서 메모리를 확보하기는 하지만 확보하는 메모리보다 메모리 사용량이 계속해서 늘어나게 되면 결국은 ",(0,r.jsx)(n.code,{children:"OutOfMemoryError"})," 가 발생하게 된다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["이 때 조심해야 할 점은 JVM 에서 ",(0,r.jsx)(n.code,{children:"OutOfMemoryError"})," 가 발생하더라도 쿠버네티스가 여기에 대해서 별도의 조치를 취하지는 않는다. 쿠버네티스의 경우 컨테이너의 전체 메모리 사용으로 인해 Out Of Memory 이슈가 생기면 쿠버네티스 레벨에서 컨테이너를 재시작 시켜주지만, 컨테이너의 메모리에서 ",(0,r.jsx)(n.code,{children:"-XX:MaxRamPercentage"})," 옵션을 통해 할당한 힙 메모리 사용량이 가득 찼을 때는 힙메모리가 가득찬 것이지 컨테이너의 전체 메모리가 가득찬 것이 아니기 때문에 JVM 애서 OOM 이 발생하더라도 컨테이너에서는 OOM 이 발생하지는 않기에 컨테이너가 재시작되지는 않는 이슈가 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["JVM 에서 OOM이 발생하는 경우에는 JVM 이 공유되거나 프로세스가 종료된다거나 그런 것은 아닌데 OOM이 발생하는 JVM 을 그대로 방치하는 것은 오류가 발생할 소지가 있다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(n.p,{children:["이런 경우 JVM 에 ",(0,r.jsx)(n.code,{children:"-XX:+ExitOnOutOfMemoryError"})," 을 지정하면 OOM이 발생했을 때 해당 컨테이너가 재시작 될수 있게끔 명시할 수 있다는 장점이 있다.",(0,r.jsx)("br",{})]})]})}let l={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.a)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/kubernetes-overview/kubernetes-resource-assignment.mdx",route:"/kubernetes-overview/kubernetes-resource-assignment",timestamp:1708484887e3,pageMap:[{kind:"Folder",name:"fibonacci-backend-cache",route:"/fibonacci-backend-cache",children:[{kind:"MdxPage",name:"backend-cache-coding",route:"/fibonacci-backend-cache/backend-cache-coding"},{kind:"MdxPage",name:"backend-cache-graceful-shutdown",route:"/fibonacci-backend-cache/backend-cache-graceful-shutdown"},{kind:"MdxPage",name:"backend-cache-jib-build",route:"/fibonacci-backend-cache/backend-cache-jib-build"},{kind:"MdxPage",name:"backend-cache-k8s-yaml",route:"/fibonacci-backend-cache/backend-cache-k8s-yaml"},{kind:"MdxPage",name:"backend-cache-kustomize",route:"/fibonacci-backend-cache/backend-cache-kustomize"},{kind:"MdxPage",name:"introduce-fibonacci-backend-cache",route:"/fibonacci-backend-cache/introduce-fibonacci-backend-cache"},{kind:"Meta",data:{"introduce-fibonacci-backend-cache":"소개","backend-cache-coding":"Backend 코드 작업","backend-cache-jib-build":"Gradle Jib 빌드 정의, 이미지 생성, 푸시","backend-cache-k8s-yaml":"k8s 리소스 정의 & 로컬 k8s 확인","backend-cache-kustomize":"Kustomize Overlay 작업","backend-cache-graceful-shutdown":"Graceful Shutdown 처리"}}]},{kind:"Folder",name:"fibonacci-backend-web",route:"/fibonacci-backend-web",children:[{kind:"MdxPage",name:"backend-web-coding",route:"/fibonacci-backend-web/backend-web-coding"},{kind:"MdxPage",name:"backend-web-graceful-shutdown",route:"/fibonacci-backend-web/backend-web-graceful-shutdown"},{kind:"MdxPage",name:"backend-web-hpa-testing",route:"/fibonacci-backend-web/backend-web-hpa-testing"},{kind:"MdxPage",name:"backend-web-jib-build",route:"/fibonacci-backend-web/backend-web-jib-build"},{kind:"MdxPage",name:"backend-web-k8s-yaml",route:"/fibonacci-backend-web/backend-web-k8s-yaml"},{kind:"MdxPage",name:"backend-web-kustomize",route:"/fibonacci-backend-web/backend-web-kustomize"},{kind:"MdxPage",name:"introduce-fibonacci-backend-web",route:"/fibonacci-backend-web/introduce-fibonacci-backend-web"},{kind:"Meta",data:{"introduce-fibonacci-backend-web":"소개","backend-web-coding":"Backend 코드 작업","backend-web-jib-build":"Gradle Jib 빌드 정의, 이미지 생성, 푸시","backend-web-k8s-yaml":"k8s 리소스 정의 & 로컬 k8s 확인","backend-web-hpa-testing":"HPA 정의 및 테스트","backend-web-kustomize":"Kustomize Overlay 작업","backend-web-graceful-shutdown":"Graceful Shutdown 처리"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"kubernetes-overview",route:"/kubernetes-overview",children:[{kind:"MdxPage",name:"hostPath-emptyDir",route:"/kubernetes-overview/hostPath-emptyDir"},{kind:"MdxPage",name:"intro",route:"/kubernetes-overview/intro"},{kind:"MdxPage",name:"kubernetes-resource-assignment",route:"/kubernetes-overview/kubernetes-resource-assignment"},{kind:"MdxPage",name:"kubernetes-scaling",route:"/kubernetes-overview/kubernetes-scaling"},{kind:"MdxPage",name:"PV-PVC",route:"/kubernetes-overview/PV-PVC"},{kind:"MdxPage",name:"storage-class",route:"/kubernetes-overview/storage-class"},{kind:"MdxPage",name:"window-directory-k8s-mount",route:"/kubernetes-overview/window-directory-k8s-mount"},{kind:"Meta",data:{intro:"소개","kubernetes-scaling":"쿠버네티스의 스케일링","kubernetes-resource-assignment":"쿠버네티스의 자원 할당","hostPath-emptyDir":"hostPath, emptyDir","PV-PVC":"PV, PVC","storage-class":"스토리지 클래스","window-directory-k8s-mount":"kubernetes hostPath 지정시 윈도우 WSL 디렉터리 경로"}}]},{kind:"Folder",name:"setup",route:"/setup",children:[{kind:"MdxPage",name:"deploy-environment",route:"/setup/deploy-environment"},{kind:"MdxPage",name:"local-k8s-setup",route:"/setup/local-k8s-setup"},{kind:"MdxPage",name:"redis-environment",route:"/setup/redis-environment"},{kind:"MdxPage",name:"reference",route:"/setup/reference"},{kind:"Meta",data:{"local-k8s-setup":"로컬 k8s 셋업","deploy-environment":"배포환경","redis-environment":"레디스 환경설정",reference:"참고한 스터디 자료들"}}]},{kind:"Meta",data:{index:"Introduction",setup:"SETUP","fibonacci-backend-cache":"fibonacci-backend-cache","fibonacci-backend-web":"fibonacci-backend-web",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Kubernetes Resource Assignment",headings:d},pageNextRoute:"/kubernetes-overview/kubernetes-resource-assignment",nextraLayout:c.ZP,themeConfig:o.Z};n.default=(0,i.j)(l)},8426:function(e,n,s){"use strict";var r=s(5893);s(7294);let i={logo:(0,r.jsx)("span",{children:"My Project"}),project:{link:"https://github.com/chagchagchag/docs-fibonacci-backend"},docsRepositoryBase:"https://github.com/chagchagchag/docs-fibonacci-backend",footer:{text:"Nextra Docs Template"}};n.Z=i},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=6426)}),_N_E=e.O()}]);