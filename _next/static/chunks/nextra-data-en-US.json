{"/setup/deploy-environment":{"title":"Deploy Environment","data":{"배포환경#배포환경":"","kustomize#Kustomize":"develop, production 사이에서 달라지는 부분들에 대해 kustomize 의 cross-cut, base/overlay 기능을 사용합니다.","argocd-argo-rollouts#ArgoCD, Argo Rollouts":"kustomize 로 구성된 yaml 리소스 정의 파일을 기반으로 일반적인 Rolling Update 방식의 단순배포를 구성하고 배포 과정을 확인해봅니다.\n이 외에도 Blue/Green, Canary 무중단 배포 방식 역시 Argo Rollouts 를 이용해 실습으로 진행해봅니다."}},"/":{"title":"Introduction","data":{"":"fibonacci-backend 프로젝트 문서 페이지\nGithub : github.com/chagchagchag/fibonacci-backend\n프로젝트 문서 : chagchagchag.github.io/docs-fibonacci-backend\n구버전 문서 : chagchagchag.github.io/fibonacci-backend-docs/\nSpring Boot 기반의 k8s 애플리케이션을 어떻게 개발해나가는지 매뉴얼을 정리"}},"/setup/local-k8s-setup":{"title":"Local K8s Setup","data":{"로컬-k8s-셋업#로컬 k8s 셋업":"","notice#Notice":"아래에서 진행하는 모든 내용들은 chagchagchag/fibonacci-backend 을 Clone 받은 후에 진행합니다.","설치-스크립트#설치 스크립트":"로컬 환경에 kind 클러스터 설치를 setup.sh 파일 하나를 실행하는 것으로 가능하게 하는 방법입니다. 아래와 같은 명령을 실행합니다.\ncd cluster\r\nsource setup.sh\n아래에서부터는 Cluster 정의가 어떻게 되는지, ArgoCD가 NodePort 로 어떻게 접속하는지, API 가 어떤 Service 에 붙어서 이 Service 를 어떤 ingress 에서 처리하는지를 정의합니다.","argocd-없이-백엔드-애플리케이션만-테스트해볼때#ArgoCD 없이 백엔드 애플리케이션만 테스트해볼때":"ArgoCD 까지 모두 띄워둔 후 작업을 하기에는 개발작업만 할 때에는 조금 부담스럽습니다.\r\nArgoCD 없이 백엔드 애플리케이션 개발만을 위한 클러스터 구성은 아래의 명령어로 가능합니다.\ncd cluster\r\nsource create-single-cluster.sh\ncluster/create-single-cluster.sh 파일의 내용은 아래와 같습니다.\necho \"\"\r\necho \"=== create Cluster & Ingress-Nginx (Ingress Controller) ===\"\r\necho \"[create] cluster creating...\"\r\nkind create cluster --name fibonacci-cluster --config=cluster.yml\r\n\r\necho \"\"\r\necho \"[create] create ingress-nginx\"\r\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\r\n\r\necho \"\"\r\necho \"[wait] wait ingress-nginx standby\"\r\nkubectl wait --namespace ingress-nginx \\\r\n  --for=condition=ready pod \\\r\n  --selector=app.kubernetes.io/component=controller \\\r\n  --timeout=90s\nsingle-cluster.yml 파일의 내용입니다.\nkind: Cluster\r\napiVersion: kind.x-k8s.io/v1alpha4\r\nnodes:\r\n  - role: control-plane\r\n    kubeadmConfigPatches:\r\n      - |\r\n        kind: InitConfiguration\r\n        nodeRegistration:\r\n          kubeletExtraArgs:\r\n            node-labels: \"ingress-ready=true\"\r\n    extraPortMappings:\r\n      - containerPort: 80 # nginx-ingress 가 인식하는 포트\r\n        hostPort: 80 # API 접속시 호스트 PC 의 80 포트로 접속\r\n        protocol: TCP","포트-사용현황#포트 사용현황":"30009 포트\nArgoCD Server\nlocalhost:30009\n80 포트\n백엔드 애플리케이션\nlocalhost/probe/healthcheck\n뒤에서 설명하는 예제들에서 사용하는 예제 애플리케이션입니다. 이번 문서에서는 설치하지 않습니다.","cluster-정의#Cluster 정의":"이 부분은 Kind 에 대한 내용을 파악하는 것인데, 귀찮다면 건너뛰셔도 됩니다.cluster.yml\nkind: Cluster\r\napiVersion: kind.x-k8s.io/v1alpha4\r\nnodes:\r\n  - role: control-plane\r\n    kubeadmConfigPatches:\r\n      - |\r\n        kind: InitConfiguration\r\n        nodeRegistration:\r\n          kubeletExtraArgs:\r\n            node-labels: \"ingress-ready=true\"\r\n    extraPortMappings:\r\n      - containerPort: 30009 # ArgoCD Node Port 를 위한 바인딩\r\n        hostPort: 30009 # ArgoCD 접속시 호스트 PC에서도 30009 로 접속\r\n        protocol: TCP\r\n      - containerPort: 80 # nginx-ingress 가 인식하는 포트\r\n        hostPort: 80 # API 접속시 호스트 PC 의 80 포트로 접속\r\n        protocol: TCP\r\n  - role: worker\r\n# - role: worker\r\n# - role: worker\nKind 클러스터는 실제로 구동될 때 하나의 Container 로 동작합니다. Kind 클러스터를 실행한 후 Docker Desktop 을 열어서 확인하면 실제 생성된 Kind 클러스터를 확인 가능합니다.extraPortMappings[i].containerPort\nKind 클러스터 컨테이너 입장에서 외부로 노출할 포트를 의미합니다. 즉 containerPort 라는 것은 Kind 클러스터 컨테이너의 Port 를 의미합니다.\nextraPortMappings[i].hostPort\n호스트 PC 즉, 개발 PC 내에서 Kind 클러스터로 접속 시에 사용할 Port 를 의미합니다.\nnodes[i].role\ncontrol-plane, worker 등을 지정해줄 수 있습니다. 만약 Cluster 가 하나의 Container 로만 구성되게끔 하려면 worker 를 사용하지 않아도 됩니다.\n경험상 단순한 백엔드 애플리케이션이나 Frontend 애플리케이션을 테스트할 때에는 worker 까지는 필요 없었고 control-plane 하나만으로도 충분히 테스트가 가능했습니다. 다만 ArgoCD 와 함께 구동 시에는 worker 가 적어도 1기 이상은 있어야 합니다.\nnext.js, nuxt.js 의 경우에도 worker 1기 이상은 있어야 파드가 정상적으로 기동되었던 것으로 기억합니다. 요즘 프론트엔드 프레임워크가 옛날 처럼 단순하고 정적인 레벨을 넘어섰기에 리소스도 어느 정도 잡아먹는 듯 합니다.","cluster-생성-cluster-내에-ingress-nginx-연동#cluster 생성, cluster 내에 ingress-nginx 연동":"클러스터는 아래와 같이 생성 가능합니다.\nkind create cluster --name fibonacci-cluster --config=cluster.yml\n이렇게 생성된 클러스터는 아래와 같이 조회 가능합니다.\nkind get clusters\nkind 클러스터가 외부와 통신이 가능하려면 Ingress 컨트롤러가 필요합니다. Ingress 컨트롤러 중 가장 대중적으로 알려진 ingress-nginx 를 kind 클러스터 내에 설치하는 명령어는 아래와 같습니다.\n## ingress-nginx 를 설치합니다.\r\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\r\n\r\n\r\n## ingress-nginx 내의 pod 이 로딩 될때 까지 kubectl wait 을 수행합니다.\r\n## 타임아웃은 90초로 주었습니다.\r\nkubectl wait --namespace ingress-nginx \\\r\n  --for=condition=ready pod \\\r\n  --selector=app.kubernetes.io/component=controller \\\r\n  --timeout=90s\n여기까지의 명령어들은 소스코드 리포지터리 내의 cluster/create-cluster.sh 파일 내에 정의해두었고, 그 내용은 아래와 같습니다.\r\ncluster/create-cluster.sh\necho \"\"\r\necho \"=== create Cluster & Ingress-Nginx (Ingress Controller) ===\"\r\necho \"[create] cluster creating...\"\r\nkind create cluster --name fibonacci-cluster --config=cluster.yml\r\n\r\necho \"\"\r\necho \"[create] create ingress-nginx\"\r\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\r\n\r\necho \"\"\r\necho \"[wait] wait ingress-nginx standby\"\r\nkubectl wait --namespace ingress-nginx \\\r\n  --for=condition=ready pod \\\r\n  --selector=app.kubernetes.io/component=controller \\\r\n  --timeout=90s","클러스터-내에-argocd-설치#클러스터 내에 ArgoCD 설치":"","argocd-설치#argocd 설치":"argocd 를 설치하기 위해서는 먼저 argocd 라는 이름의 namespace 를 하나 생성해줘야 합니다.\nkubectl create namespace argocd\n이번에는 argocd 를 구성하는 리소스들을 클러스터 내에 생성하도록 kubectl 로 요청하는 절차입니다.\nkubectl -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n이번에는 이렇게 생성된 argocd 관련 리소스 들 에 대해 SSL 옵션을 끄는 명령입니다.\nkubectl -n argocd patch deployment argocd-server --type json -p='[{\"op\":\"replace\",\"path\":\"/spec/template/spec/containers/0/args\",\"value\":[\"/usr/local/bin/argocd-server\",\"--insecure\"]}]'\n생성된 argocd 에서는 admin 이라는 사용자에 대해 초기 password 가 부여되는데 초기 패스워드는 아래의 명령어로 확인 가능합니다.\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d\n여기까지 ArgoCD를 모두 설치했습니다. 이렇게 클러스터 내에 설치한 ArgoCD 는 Kind 클러스터 외부, 즉, 호스트 PC(개발PC)에서 접속 가능하려면 Ingress, Nodeport, ClusterIP 등을 이용해 접근이 가능합니다.Ingress 를 사용할 경우 80, 443 포트만 매핑이 가능한데, 80, 443 포트에 대한 / 경로 접근은 애플리케이션을 위해 예약되어 있다. 따라서 이번 예제에서는 ArgoCD 에 Ingress 를 통해 접근하게끔 하지 않을 예정입니다.ArgoCD 를 / 경로로 Ingress 를 통해 ArgoCD 하나를 위해 독자적으로 80, 443 포트로 접근하는 예제가 필요하다면 추후 별도로 Kind 클러스터 세팅에 대해서 정리할 예정이기에 별도의 문서를 참고해주시기 바랍니다.\nClusterIP 를 사용할 경우 클러스터 내에 배포된 argocd-server 의 IP를 알고 있다면 접근이 가능합니다. 이렇게 한다면, 매번 유동적으로 바뀌는 IP를 직접 CLI 로 체크해서 접속해야 하는 불편함이 있습니다.\n이번 예제에서 사용하는 ArgoCD 는  30009 포트에 매핑한 NodePort 를 사용합니다. NodePort를 통해서 ArgoCD가 클러스터 외부와 30009 포트의 / 을 통해 통신을 할 수 있도록 구성했습니다.","nodeport-정의#nodeport 정의":"포트 매핑\n호스트 PC → [클러스터 30009 : NodePort 30009 → 80:8080(argocd-server)]\n위에서 이야기 했듯 이번 예제 프로젝트에서 ArgoCD 는 NodePort 를 통해서 ArgoCD가 클러스터 외부와 30009 포트의 / 경로를 통해 통신을 할 수 있도록 구성했습니다.이렇게 정의한 NodePort 의 역할은 Kind 클러스터 외부(호스트PC)로부터 특정 Port (30009) 로 온 요청을 Kind 클러스터 내부에 argocd-server-nodeport라는 NodePort 로 매핑하고, 이 NodePort 는 ArgoCD 리소스로 연결해주는 역할입니다.\nargocd-nodeport.yml\r\nargocd-nodeport 라는 이름의 NodePort 리소스를 정의한 리소스 정의 파일입니다.\n---\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  labels:\r\n    app: argocd-server-nodeport\r\n  name: argocd-server-nodeport\r\n  namespace: argocd\r\nspec:\r\n  ports:\r\n  - name: \"80\"\r\n    port: 80\r\n    targetPort: 8080\r\n    nodePort: 30009\r\n    protocol: TCP\r\n  selector:\r\n    app.kubernetes.io/name: argocd-server\r\n  sessionAffinity: None\r\n  type: NodePort\n이렇게 정의한 nodeport 는 아래와 같이 kubectl 로 클러스터에 리소스를 생성하도록 요청할 수 있습니다.\nkubectl apply -f argocd-nodeport.yml","argocd-생성-스크립트#ArgoCD 생성 스크립트":"여기까지 작성한 모든 ArgoCD 생성 스크립트는 cluster/setup-argocd.sh 파일 내에 정의했습니다.cluster/setup-argocd.sh\necho \"\"\r\necho \"[create] namsepace 'argocd'\"\r\nkubectl create namespace argocd\r\n\r\necho \"\"\r\necho \"[install] kubectl apply -f argoprj/argo-cd/.../install.yaml\"\r\nkubectl -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\r\n\r\necho \"\"\r\necho \"[configure] --insecure configure\"\r\nkubectl -n argocd patch deployment argocd-server --type json -p='[{\"op\":\"replace\",\"path\":\"/spec/template/spec/containers/0/args\",\"value\":[\"/usr/local/bin/argocd-server\",\"--insecure\"]}]'\r\n\r\necho \"\"\r\necho \"[status] kubectl -n argocd get all\"\r\nkubectl -n argocd get all\r\n\r\necho \"\"\r\necho \"wait(45s) ... \"\r\nsleep 45\r\n\r\necho \"\"\r\necho \"[password!!!] your password\"\r\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d\r\n\r\necho \"\"\r\necho \"\"\r\necho \"wait(45s) ... \"\r\nsleep 45\r\n\r\necho \"\"\r\necho \"[setup] nodeport (argocd-nodeport)\"\r\nkubectl apply -f argocd-nodeport.yml\n쉘 스크립트에서 사용하고 있는 argocd-nodeport.yml 파일의 내용은 아래와 같습니다.\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  labels:\r\n    app: argocd-server-nodeport\r\n  name: argocd-server-nodeport\r\n  namespace: argocd\r\nspec:\r\n  ports:\r\n  - name: \"80\"\r\n    port: 80\r\n    targetPort: 8080\r\n    nodePort: 30009\r\n    protocol: TCP\r\n  selector:\r\n    app.kubernetes.io/name: argocd-server\r\n  sessionAffinity: None\r\n  type: NodePort","setupsh#setup.sh":"여기까지 작성한 모든 내용들은 cluster/setup.sh 파일에서 호출하고 있습니다.\r\ncluster/setup.sh 파일의 내용은 아래와 같습니다.cluster/setup.sh\necho \"\"\r\necho \">>> [create-cluster.sh]\"\r\nsource create-cluster.sh\r\n\r\necho \"\"\r\necho \">>> [setup-argocd.sh]\"\r\nsource setup-argocd.sh"}},"/setup/redis-environment":{"title":"Redis Environment","data":{"redis-환경설정#Redis 환경설정":""}},"/setup/reference":{"title":"Reference","data":{"참고했던-스터디-자료들#참고했던 스터디 자료들":"혹시라도 처음으로 쿠버네티스를 스터디해야 하는 분들이거나, 회사에 있는 레거시를 쿠버네티스 기반으로 전환해야 하지만 자료가 없어서 답답하신 분들이 계시다면 아래 자료를 참고해주세요. 저는 혼자 공부하느라 아무것도 모른 채로 몇번 실패해서 읽어본것도 있고  강의를 듣다가 '이건 도저히 안되는 강의네' 하면서 수강을 포기한 강의도 있습니다. 아래에 정리한 자료들은 모두 직접 경험해본 후 실제로 도움이 되었던 자료들입니다.","강의#강의":"한번에 끝내는 CI/CD Docker 부터 GitOps 까지\nKustomize, ArgoCD, EKS 설치 등등 백엔드 개발자가 어렵게 여기는 인프라에 대해 설명이 잘되어 있습니다. 아직 강의를 30% 만 수강해둔 상태여서 더 많은 강의를 들어야 합니다.\n백엔드 개발자를 위한 Kubernetes : 클라우드 네이티브 프로그래밍\n백엔드 개발자 분이 강의를 해주십니다. 강의 내에 해주시는 설명 중에 놓치기 아까운 부분들이 많아서 받아적느라 힘들었습니다. 강의 자료가 PPT에 몇몇 단어나 문장으로만 되어있어서 복습할 때 강의를 한번 더 들어야 한다는 멘탈붕괴에 빠진다는 단점이 있습니다.\n이 강의를 들으신다면, 두 번째 복습때는 꼭 필기를 하셔야 합니다.\n그런데 내용이 정말 알찹니다. 보장합니다.","eks-workshop-studio#EKS Workshop Studio":"Amazon EKS 로 웹 애플리케이션 구축하기\nBuilding Web Applications based on Amazon EKS","블로그#블로그":"blog.naver.com/alice_k106","책#책":"최근 1년 사이에 읽었던 책만 추렸습니다.\n클라우드 네이티브를 위한 쿠버네티스 실전 프로젝트\n핵심만 콕! 쿠버네티스\n쿠버네티스 패턴 - 클라우드 네이티브 애플리케이션 설계와 구현을 위한 24가지 디자인 패턴"}}}